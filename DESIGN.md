# 設計書：デュエル・オブ・フュージョン

## 1. プロジェクト概要

* **目的**: 本作『デュエル・オブ・フュージョン』は、戦略的なカードバトルを楽しめるデジタルカードゲームです。
本プロジェクトは、プレイヤーに以下のユニークなゲーム体験を提供することを主な目的としています。

斬新な戦略性の提供:
独自の「フュージョンデッキシステム（両プレイヤーのデッキを予め混ぜ合わせて共有山札とするルール）」により、従来のカードゲームにはない予測不能な展開を生み出します。プレイヤーは相手のカードをも自らの戦略に組み込む柔軟な思考力と、状況に応じた即興的な判断力を駆使して勝利を目指します。これにより、毎回の対戦が新鮮でリプレイ性の高い体験となることを目的とします。

直接的でダイナミックな攻防の実現:
「デッキマスターシステム（プレイヤーのライフポイントを兼ねる5体のユニット）」を導入することで、抽象的なライフポイントの削り合いではなく、盤上の具体的なユニットへの攻撃と防御をゲームの中心に据えます。これにより、どのデッキマスターを優先して攻撃/防御するかといった戦術的な深みと、ダイレクトな戦闘の駆け引きの面白さを提供します。

多様な戦術の探求とデッキ構築の楽しみ:
現在実装されている「スチームパンク・オートマタ」「天空の詠唱者」「深淵の招魂師団」といった特徴の異なる複数のカードテーマを通じて、プレイヤーが自分だけのオリジナルデッキを構築し、多様な戦術やコンボを探求する楽しみを提供します。

また、本プロジェクトは制作者のポートフォリオの一部として、以下の技術的・設計的目標の達成も目的としています。

Web技術によるゲーム開発能力の実証:
HTML、CSS、JavaScript（ES6+）という基本的なWeb技術のみを使用し、外部ライブラリに極力頼らずに、インタラクティブで複雑なルールを持つゲームアプリケーションをゼロから設計・実装する技術力を示すこと。

ゲームデザインとバランス調整能力の習得と実践:
オリジナルのカード効果、ゲームルール、テーマデッキを考案し、それらのバランスを実際にプレイテストしながら調整していくプロセスを通じて、ゲームデザインの基礎と面白さを追求する能力を実践的に学ぶこと。

ソフトウェアエンジニアリングの基礎実践:
ユニットテストの導入（Jest使用）、設計ドキュメントの作成、コードのリファクタリングといった活動を通じて、コードの品質、可読性、保守性を意識した開発プロセスを体験し、堅牢なソフトウェアを構築するための基本的なエンジニアリングプラクティスを身につけること。


* **開発動機**: 特にこだわったのは、既存のカードゲームの枠組みに囚われない、デジタルならではの新しい遊びの提供です。

第一に、紙のカードゲームでは物理的な制約から実現が難しい「両プレイヤーのデッキを融合させ、一つの巨大な山札として共有する」という大胆なルールを採用しました。これにより、毎回のドローが予測不能なものとなり、相手のカードすら自らの戦略に組み込む柔軟な思考とアダプティブな対応力が求められる、スリリングで奥深い対戦体験が生まれると考えました。これは、ゲームタイトルにも込めた「フュージョン（融合）」というコンセプトの核となっています。

第二に、従来のライフポイントシステムに代わる、より直接的で戦略的な攻防を生み出す要素として、「自身のライフポイントとしての役割も担う5体のデッキマスター」という独自の概念を導入しました。これらのデッキマスターは、単なる体力ゲージではなく、それぞれが守るべき城であり、破壊すべき具体的なターゲットとなります。どのデッキマスターから攻めるか、あるいは自軍のどのデッキマスターをどう守るかといった、盤面に応じた駆け引きの深まりと、勝利条件の明確化を目指しました。

これらの独自のメカニクスを通じて、プレイヤーにこれまでにない新鮮な戦略的思考の楽しさと、対戦の度に異なる展開が待ち受ける興奮を提供したいという思いが、この「デュエル・オブ・フュージョン」開発の大きな動機となりました。

## 2. 技術スタック

* **使用言語**: HTML5, CSS3, JavaScript (ES6+)
* **テストフレームワーク**: Jest
* **開発環境**: VS Code, Node.js (Jest実行のため), Live Server (VS Code拡張機能)など


## 3. アーキテクチャ

### 3.1. ファイル構成

* `index.html`: ゲームの骨格となるUI構造（各画面、ゾーン、ボタンなど）を定義。
* `style.css`: ゲーム全体のデザイン、レイアウト、カードの見た目、視覚効果を定義。
* `script.js`: ゲームのメインロジック。UI要素の取得、イベントリスナーの設定、ゲーム進行管理、DOM操作による画面更新など、現在ほぼ全てのクライアントサイド処理を担う。
* `gameLogic.js`: `script.js`から分離された、UIに依存しない純粋なゲームロジック関数（`shuffleArray`, `drawOneCard`, `resolveCombatRound`など）を格納。ユニットテストの対象。
* `*.test.js` (例: `shuffleArray.test.js`): 各ロジック関数に対応するJestのユニットテストコード。

### 3.2. 状態管理 (State Management)

* ゲームの全ての状態は、`script.js`内で定義されているグローバルな`gameState`オブジェクトによって一元管理される。
* **`gameState`の主要なプロパティ説明**:
    * `turn`, `currentPhase`, `currentPlayer`: ゲームの進行状況。
    * `self`, `opponent`: 各プレイヤーの状態オブジェクト。
        * `currentMana`, `maxMana`: マナ情報。
        * `deckMasters`: デッキマスターの状態（場にいるか、HPなど）。
        * `hand`: 手札のカード情報。
        * `field`: フィールドのクリーチャー情報（`{card, currentHP, powerCounters, hasActedThisTurn, isAwakened}`など）。
        * `destroyedDeckMastersCount`: 破壊されたデッキマスターの数。
        * `spellsCastThisTurn`: `[連鎖]`判定用。
        * `solarisAbilityUsedThisTurn`, `licheAbilityUsedThisTurn`: 特定DMの能力使用フラグ。
        * `nextSpellCostReduction`: 《魔力循環》用。
    * `mainDeck`: 共通の山札。
    * `graveyard`: 共通の墓地。
    * `awaitingSpellTarget`, `pendingSolarisEffect`: スペルや能力のターゲット選択中の一時情報。
* `gameState`は「唯一の信頼できる情報源 (Single Source of Truth)」とし、全ての描画処理(`renderHand`, `renderField`など)はこのオブジェクトの状態に基づいて行われる。

### 3.3. 主要なロジックフロー

* **ゲーム開始 (`initializeGame`)**: デッキシャッフル、初期手札配布、デッキマスター配置、初期マナ設定など。
* **ターン進行**: ドローフェーズ → メインフェーズ → （攻撃フェーズ） → エンドフェーズ。
* **カードプレイ (`handleCardClick`)**: マナ消費、手札から場へ移動、効果解決（`resolveOnSummonEffect`, `resolveSpellEffect`）。
* **戦闘処理 (`performCombat` -> `gameLogic.js`の`resolveCombatRound`を利用予定)**: ATK計算（バフ、能力考慮）、HP計算、破壊処理（`destroyCard`）。
* **AIのターン (`startOpponentTurn`)**: ドロー、マナ、クリーチャー召喚、攻撃といった一連の思考ロジック。

## 4. テスト方針

* **目的**: ゲームのコアロジックの品質保証、機能追加・修正時のバグ混入（デグレード）防止。
* **手法**: Jestを用いたユニットテスト。
* **対象**: `gameLogic.js`に分離された、UIに依存しない純粋な関数を主とする。
    * 現在テスト済みの関数: `shuffleArray`, `drawOneCard`, `resolveCombatRound` (基本パターン)。
* **今後の拡充**:
    * `resolveCombatRound`のテストケース追加（ワイト、コア・マキナ覚醒、カウンターを組み合わせた複雑なケースなど）。
    * スペル効果解決ロジックのテスト（例：火球、手札補充など）。
    * 召喚時効果解決ロジックのテスト（例：コア・マキナ覚醒条件判定、リッチェのミル＆チューターなど）。

## 5. 今後の課題・拡張予定

* **UI/UX改善**:
    * 墓地確認機能の実装。
    * サウンドエフェクト、BGMの追加。
    * カードプレイや戦闘時のアニメーション追加。
* **未実装のカード能力**:
    * エレメンタリスト：《魔力循環》のコスト軽減の完全実装、《ソラリス》の常時能力（ダメージ効果のターゲット選択と実行）。
    * ネクロマンサー：《リッチェ》の起動能力、《血の儀式の司祭》の起動能力。
* **AIの強化**: より戦略的な思考ルーチンの実装。
* **カード追加とバランス調整**。
* **ネットワーク対戦機能の検討**。


## 2. 技術スタック

本プロジェクト「デュエル・オブ・フュージョン」の開発およびテストには、以下の技術・ツールを中心に使用しています。

* **HTML5**:
    * ゲームの基本的な骨格、画面構成（各ゾーン、ボタン、モーダルウィンドウなど）のマークアップに使用しています。ウェブアプリケーションの標準技術として採用しました。

* **CSS3**:
    * カードデザイン、フィールドレイアウト、ボタンのスタイリング、全体的なビジュアルデザインを担当しています。ゲームの世界観を表現し、ユーザーが直感的に操作しやすいインターフェースを目指して活用しています。

* **JavaScript (ES6+)**:
    * ゲームのほぼ全ての動的処理を担当しています。これには、ゲームの進行管理（ターン、フェイズ）、カードの能力解決、プレイヤーのアクション処理、AIの思考ルーチン、DOM操作による画面の描画更新などが含まれます。外部のゲームエンジンや大規模なライブラリに依存せず、基本的なJavaScriptの機能を中心に実装することで、言語への理解を深めることを目的の一つとしています。

* **Git**:
    * プロジェクトのバージョン管理システムとして使用しています。変更履歴の記録、ブランチを活用した機能追加（将来的な構想）、バックアップなどを目的として導入しました。

* **GitHub**:
    * Gitリポジトリのホスティングサービスとして利用しています。ソースコードの管理・共有に加え、GitHub Pages機能を利用してゲームをインターネット上に公開し、第三者からのフィードバックを得る場としても活用しています。

* **GitHub Pages**:
    * 完成したゲームを静的サイトとしてホスティングし、ウェブブラウザ経由で誰でもアクセスしてプレイできるようにするために使用しています。

* **Node.js / npm**:
    * 開発環境のセットアップ、特にユニットテストフレームワークであるJestの実行環境として導入しました。`package.json`によるプロジェクト管理も行っています。

* **Jest**:
    * JavaScriptのユニットテストフレームワークとして採用しました。`gameLogic.js`に分離した純粋関数（例：山札シャッフル、カードドロー、戦闘ダメージ計算など）を中心にテストを作成し、コードの品質保証、リグレッション（意図しないバグの再発）防止、リファクタリング時の安全性の向上を目指しています。

* **Visual Studio Code (VS Code)**:
    * 主要なコードエディタとして使用しています。豊富な拡張機能（例: Live Server）、デバッグ機能、Git連携機能などを活用し、開発効率の向上を図っています。

* **Live Server (VS Code Extension)**:
    * 開発中のゲームをローカルサーバーで起動し、ブラウザでリアルタイムに動作確認を行うために使用しています。コード変更時の自動リロード機能により、迅速なフィードバックループを実現しています。

### 3.1. ファイル構成

本プロジェクト「デュエル・オブ・フュージョン」は、以下の主要なファイル群で構成されています。

* **`index.html`**:
    * ゲームのメインとなるHTMLファイルです。
    * 画面の基本的な骨格（各ゾーン、ボタン、モーダルウィンドウなど）を定義し、スタイルシート (`style.css`) とメインのJavaScript (`script.js`) を読み込みます。

* **`style.css`**:
    * ゲーム全体の見た目、レイアウト、カードデザイン、アニメーション（CSSで対応可能な範囲）などのスタイル情報を定義しています。
    * 視覚的な分かりやすさと、ゲームの世界観を補助する役割を担います。

* **`script.js`**:
    * ゲームの主要なクライアントサイドロジックを記述している最も中心的なファイルです。
    * UI要素の取得とキャッシュ (`uiElements`)、イベントリスナーの設定、ゲームの進行管理（ターン、フェイズ）、主要な状態管理オブジェクト (`gameState`) の定義と更新、DOM操作による画面描画関数の呼び出し（`renderHand`, `renderField`など）、カード効果の解決ロジック（`resolveSpellEffect`, `resolveOnSummonEffect`など）、戦闘処理 (`performCombat`)、AIの基本的な行動パターン (`startOpponentTurn`)、デッキ編集機能のロジックなど、現状のゲーム動作の大部分をこのファイルで制御しています。
    * （将来的には、テスト容易性や保守性向上のため、UI操作、ゲームロジック、AIロジックなどをさらに別ファイルに分割することを検討しています。）

* **`gameLogic.js`**:
    * `script.js`から分離された、UIに直接依存しない純粋なゲームロジック関数（例：山札シャッフル `shuffleArray`、カードを1枚引くコア処理 `drawOneCard`、戦闘ダメージ計算 `resolveCombatRound`、見習い詠唱者のカウンター処理 `applyApprenticeChanterGrowth`など）を格納しています。
    * これらの関数は、Jestによるユニットテストの対象となり、ゲームロジックの信頼性を担保する役割を持ちます。

* **`utils.js`** (もし作成した場合):
    * プロジェクト全体で使用する可能性のある、より汎用的な補助関数（例：特定の計算処理、文字列操作など、ゲームのドメイン知識に直接依存しないもの）を格納します。
    * （※現状では`shuffleArray`は`script.js`のトップレベルにありますが、将来的にはこちらや`gameLogic.js`に完全に移行し、モジュールとして管理することを検討しています。）

* **`*.test.js`** (例: `shuffleArray.test.js`, `drawOneCard.test.js`, `resolveCombatRound.test.js`, `apprenticeChanter.test.js`など):
    * `gameLogic.js`などに定義された各関数に対するJestのユニットテストコードを記述しています。
    * 各テストファイルは、対応するロジックが仕様通りに正しく動作することを検証します。

* **`.gitignore`**:
    * Gitのバージョン管理システムから除外するファイルやフォルダ（主に`node_modules/`フォルダ）を指定しています。これにより、リポジトリをクリーンに保ちます。

* **`package.json`**:
    * プロジェクトの情報（名前、バージョンなど）や、開発に使用する依存パッケージ（現在はJestのみ）、テスト実行用のスクリプト (`"test": "jest"`) などを定義しています。Node.jsプロジェクトの標準的な管理ファイルです。

* **`package-lock.json`**:
    * `npm install`によってインストールされたパッケージの正確なバージョン情報とその依存関係を記録しています。これにより、他の環境でも同じバージョンのパッケージを再現性高くインストールできます。

* **`README.md`**:
    * プロジェクトの概要、目的、遊び方、技術スタックなどを記述した、プロジェクトの「顔」となるドキュメントです。GitHubリポジトリのトップページに表示されます。

* **`DESIGN.md`** (このドキュメント自身):
    * ゲームの設計思想、アーキテクチャ、詳細な仕様、今後の課題などを記述する、より詳細な設計ドキュメントです。

 ### 3.2. 状態管理 (State Management)

本ゲーム「デュエル・オブ・フュージョン」における全ての動的な状態は、`script.js`内でグローバルに定義されている単一のオブジェクト`gameState`によって一元的に管理されています。この`gameState`オブジェクトは「唯一の信頼できる情報源 (Single Source of Truth)」として機能し、ゲームの進行、プレイヤーのアクション、UIの表示など、あらゆる側面がこのオブジェクトの状態に基づいて決定・更新されます。

以下に`gameState`オブジェクトの主要なプロパティとその役割を示します。

* **`turn`**: `number`
    * 現在のゲームのターン数を記録します。各プレイヤーのターン開始時にインクリメントされます（プレイヤーのドローフェイズ開始時）。

* **`currentPhase`**: `string`
    * 現在のゲームフェイズを示します。取りうる値は以下の通りです。
        * `'draw'`：プレイヤーのドローフェイズ
        * `'main'`：プレイヤーのメインフェイズ
        * `'attack'`：プレイヤーのアタックフェイズ
        * `'opponent_turn_processing'`：相手（CPU）のターン処理中
        * `'gameOver'`：ゲーム終了状態
    * この値に基づいて、プレイヤーが実行可能なアクションやUI（ボタンの有効/無効など）の表示が制御されます。

* **`currentPlayer`**: `string`
    * 現在アクティブなプレイヤーを示します。値は `'self'`（人間プレイヤー）または `'opponent'`（CPUプレイヤー）です。

* **`selectedAttacker`**: `object | null`
    * プレイヤーが自分のフィールドから攻撃クリーチャーを選択した際、そのクリーチャーのフィールドオブジェクト（例：`{ card: CardObject, currentHP: number, slotIndex: number, hasAttacked: boolean, powerCounters: number, isAwakened?: boolean }`）を一時的に保持します。攻撃が完了またはキャンセルされると`null`に戻ります。

* **`awaitingSpellTarget`**: `object | null`
    * ターゲットを必要とするスペルや能力が使用され、ターゲット選択待ちの状態であることを示す情報を保持します。オブジェクトには通常、以下の情報が含まれます。
        * `card`: 効果の発生源となったカードの基本データ (`CardObject`)
        * `player`: 効果を使用したプレイヤー (`'self'` または `'opponent'`)
        * `effect`: 適用される効果の詳細オブジェクト（例：`{ type: 'damage', value: 3, targetCategory: 'creature', ... }`）
        * `calculatedValue` (オプション): `[連鎖]`効果などで計算された最終的な効果量
        * `isSolarisEffect` (オプション): ソラリスの常時効果によるターゲット指定であることを示すフラグ
    * ターゲットが選択されるか、ターゲット選択がキャンセルされると`null`に戻ります。

* **`pendingSolarisEffect`**: `object | null`
    * 《大魔導師ソラリス》の常時効果が誘発し、そのダメージ効果のターゲット選択中に、元々プレイされたスペルの情報を一時的に保持します（例：`{ originalSpell: CardObject }`）。ソラリスの効果解決後に元のスペル効果を解決するために使用されます。

* **`mainDeck`**: `Array<CardObject>`
    * 両プレイヤーのデッキカード（各30枚、計60枚）を混ぜ合わせた共通の山札です。カードの基本データオブジェクト (`CardObject`) の配列として管理されます。ゲーム開始時に生成・シャッフルされ、ドローによって先頭から要素が取り除かれます。

* **`graveyard`**: `Array<CardObject>`
    * 破壊されたクリーチャーや使用済みのスペルが置かれる共通の墓地です。カードの基本データオブジェクト (`CardObject`) の配列として管理されます。

* **`self`**: `PlayerStateObject` (人間プレイヤーの状態オブジェクト)
* **`opponent`**: `PlayerStateObject` (CPUプレイヤーの状態オブジェクト)
    * 上記2つのオブジェクトは同じ構造を持ち、プレイヤー固有の状態を管理します。主要なプロパティは以下の通りです。
        * **`currentMana`**: `number` - 現在のターンで使用可能なマナの量。
        * **`maxMana`**: `number` - 現在のターンのマナの最大値（毎ターン1ずつ増加、最大10）。
        * **`deckMasters`**: `Array<DeckMasterFieldObject>` - 各プレイヤーが持つ5体のデッキマスターの状態を保持する配列。
            * `DeckMasterFieldObject`: `{ card: CardObject, currentHP: number, isSummoned: boolean }`
                * `card`: デッキマスターの基本カードデータ。
                * `currentHP`: デッキマスターの現在のHP。
                * `isSummoned`: デッキマスターがフィールドに召喚されているかを示すフラグ。
        * **`hand`**: `Array<CardObject>` - 現在の手札にあるカードの基本データオブジェクトの配列。
        * **`field`**: `Array<CreatureFieldObject | null>` - フィールド上の5つのスロットの状態を保持する配列。空のスロットは`null`。
            * `CreatureFieldObject`: `{ card: CardObject, currentHP: number, hasAttacked: boolean, powerCounters: number, isAwakened?: boolean }`
                * `card`: フィールド上のクリーチャーの基本カードデータ。
                * `currentHP`: クリーチャーの現在のHP。
                * `hasAttacked`: そのターンに既に攻撃（または「行動済み」となる能力を使用）したかを示すフラグ。ターン終了時にリセット。
                * `powerCounters`: 《見習い詠唱者》などが持つパワー（+1/+1）カウンターの数。
                * `isAwakened` (オプション): 《機構長 コア・マキナ》のような特定のカードが覚醒状態かを示すフラグ。
        * **`destroyedDeckMastersCount`**: `number` - 破壊された（ゾーンにある未召喚の）デッキマスターの数。ゲームの勝敗判定に使用。
        * **`spellsCastThisTurn`**: `number` - `[連鎖]`能力の判定に使用する、そのターンにプレイされたスペルの数。ターン開始時にリセット。
        * **`solarisAbilityUsedThisTurn`**: `boolean` - 《大魔導師ソラリス》の起動能力がそのターン既に使用されたかを示すフラグ。ターン開始時にリセット。
        * **`licheAbilityUsedThisTurn`**: `boolean` - 《大巫女 リッチェ》の起動能力がそのターン既に使用されたかを示すフラグ。ターン開始時にリセット。
        * **`nextSpellCostReduction`**: `number` - 《魔力循環》などによって、次にプレイするスペルのコストがどれだけ軽減されるかを示す値。スペル使用後に0にリセット。

`gameState`の変更は、プレイヤーのアクション（カードプレイ、攻撃宣言など）やターン進行に応じて、`script.js`内の各ゲームロジック関数内で行われます。状態が変更された後は、`updateAllUI()`関数（内部で`updateUI`, `renderHand`, `renderField`, `renderDeckMasters`を呼び出す）が呼び出され、画面表示が最新の`gameState`に基づいて同期されます。


function pseudo_handlePlayerTurnCycle(player) {
    // === ターン開始処理 (相手のエンドフェイズ終了後など) ===
    // gameState.currentPlayer を player に設定
    // gameState.currentPhase を 'draw' に設定
    // gameState.turn をインクリメント (最初のプレイヤーのターン開始時など)
    // gameState[player].spellsCastThisTurn = 0;
    // gameState[player].solarisAbilityUsedThisTurn = false;
    // gameState[player].licheAbilityUsedThisTurn = false;
    // gameState[player].nextSpellCostReduction = 0;
    // gameState[player].maxMana を増加 (上限10)
    // gameState[player].currentMana を maxMana に回復
    // callFunction_updateAllUI(); // 全UIを更新

    // === ドローフェイズ (例: ドローボタンクリックイベント) ===
    // if (gameState.currentPhase === 'draw' && gameState.currentPlayer === player) {
    //     if (callFunction_drawCardToHand(player)) { // 実際の描画とgameState更新はdrawCardToHand内
    //         gameState.currentPhase = 'main';
    //     }
    //     callFunction_updateAllUI();
    // }

    // === メインフェイズ ===
    // プレイヤーのアクション待ち (カードプレイ、能力起動、攻撃フェイズへ移行、ターン終了)
    // 例: 攻撃ボタンがクリックされた場合
    // if (/* 攻撃ボタンクリック */ gameState.currentPhase === 'main' && gameState.currentPlayer === player) {
    //     gameState.currentPhase = 'attack';
    //     callFunction_cancelSpellTargeting(); // 保留中のスペルターゲットをキャンセル
    //     callFunction_resetAttackState();   // 選択中の攻撃情報をリセット
    //     // UIに「攻撃フェイズ」と表示
    //     callFunction_updateAllUI();
    // }

    // === アタックフェイズ ===
    // プレイヤーのアクション待ち (攻撃クリーチャー選択、攻撃対象選択、ターン終了)
    // 例: ターン終了ボタンがクリックされた場合
    // if (/* ターン終了ボタンクリック */ (gameState.currentPhase === 'main' || gameState.currentPhase === 'attack') && gameState.currentPlayer === player) {
    //     callFunction_resetAttackState();
    //     callFunction_cancelSpellTargeting();
    //     // プレイヤーの手札上限処理
    //     // プレイヤーのフィールドクリーチャーの hasAttacked フラグをリセット
    //     // gameState.currentPlayer を相手プレイヤーに変更
    //     // 相手プレイヤーの各種フラグをリセット
    //     callFunction_updateUI();
    //     // setTimeout(callFunction_startOpponentTurn, 1000); // 相手ターン処理へ
    // }
}


## 4. テスト方針 (Testing Strategy)

本プロジェクト「デュエル・オブ・フュージョン」では、ゲームロジックの品質保証、バグの早期発見、及び将来的な機能追加・リファクタリング時の安全性向上を目的として、ユニットテストを導入・実施しています。

### 4.1. 使用フレームワーク及び実行環境

* **テストフレームワーク**: `Jest`
    * JavaScriptのテスティングフレームワークとして広く採用されており、設定の容易さや豊富なアサーション（検証）機能、モック機能などを評価し選定しました。
* **実行環境**: `Node.js`
    * Jestの実行に必要なNode.js環境を構築し、`npm` (Node Package Manager) を通じてJestをプロジェクトの依存関係として管理しています。
* **テスト実行コマンド**: `npm test`
    * `package.json`にスクリプトを登録し、このコマンドでプロジェクト内の全てのテストスイートを実行します。

### 4.2. 現在の主なテスト対象と内容

主に、UIから分離可能で、純粋なロジックとしてテストできる関数を`gameLogic.js`に配置し、それらを対象としています。各テストファイル (`*.test.js`) は、対応するロジックの仕様に基づき、正常系および代表的な境界値を検証します。

* **`shuffleArray`関数 (`shuffleArray.test.js`)**:
    * 配列の要素数を変更せずにシャッフルすること。
    * シャッフル後も元の要素を全て含んでいること（要素の欠損や重複がないこと）。
    * 空の配列や要素が1つの配列を入力した場合でも、エラーなく適切に処理されること。

* **`drawOneCard`関数 (`drawOneCard.test.js`)**:
    * 指定された山札（配列）からカードを1枚引き、指定された手札（配列）に正しく加えられること（山札と手札の枚数変化、移動したカードオブジェクトの検証）。
    * 引かれたカードが、元の山札の先頭のカードと一致すること。
    * 山札が空の場合に、カードが引かれず、その状態を示すフラグ (`deckEmpty: true`) が正しく返されること。
    * 関数が純粋性を保ち、元の山札・手札オブジェクト（引数として渡された配列）を直接変更しないこと。

* **`resolveCombatRound`関数 (`resolveCombatRound.test.js`)**:
    * 基本的なクリーチャー同士の戦闘における、双方のHPの正しい減少量。
    * 戦闘結果としての各クリーチャーの破壊判定（HPが0以下になったか）が正しいこと。
    * パワーカウンターを持つクリーチャーの攻撃力が、戦闘ダメージ計算に正しく反映されること。
    * 《魂集めのワイト》の常時能力（墓地のクリーチャー数に応じたATK上昇）が、戦闘ダメージ計算に正しく反映されること。
    * 《機構長コア・マキナ》の覚醒状態での特殊な攻撃力が、戦闘ダメージ計算に正しく反映されること。
    * 防御側がゾーンにいる未召喚デッキマスターの場合、反撃が発生せず、攻撃側のHPが減少しないこと。

* **`applyApprenticeChanterGrowth`関数 (`apprenticeChanter.test.js`)**:
    * 対象が《見習い詠唱者》である場合に、`powerCounters`プロパティが正しく1増加すること。
    * 既にあるカウンターにさらに1加算されること。
    * 対象が《見習い詠唱者》でないクリーチャーの場合、`powerCounters`が変化しない（またはオブジェクトが変更されない）こと。
    * 無効な引数（例: `null`や不完全なオブジェクト）が渡された場合でも、関数がエラーで停止せず、安全に処理を終えること。

### 4.3. 今後のテスト拡充計画

現状テストされているのは一部のコアロジックに留まるため、今後`gameLogic.js`へのロジック分離を進めるとともに、以下のテストを拡充していく計画です。

* **カード効果ロジックの網羅性向上**:
    * 各カードの召喚時効果（`resolveOnSummonEffect`関数から切り出される、より詳細な効果ごとの純粋ロジック）。
        * 例：《機構長コア・マキナ》の覚醒条件判定ロジック、《大巫女リッチェ》のミル＆チューター効果の各ステップなど。
    * 各スペルの効果（`resolveSpellEffect`関数から切り出されるロジック）。
        * 例：《火球》のダメージ適用、《手札補充》のドロー枚数、《魔力循環》のコスト軽減フラグ設定など。
    * 起動能力のコアロジック（`handleFieldCreatureClick`関数から切り出されるロジック）。
        * 例：《大巫女リッチェ》の生贄と蘇生処理の純粋な状態変化部分、《血の儀式の司祭》のドローと回復処理など。
* **境界値テスト・異常系テストの追加**:
    * 最大マナ/最小マナ、最大手札/最小手札、フィールド満杯/空きなし、山札切れ寸前など、ゲームの様々な極限状態におけるロジックの動作テスト。
    * 予期せぬ入力や不正な状態に対する関数の堅牢性テスト。
* **状態変化の網羅性**:
    * `gameState`の各重要なプロパティが、特定のゲームイベント（ターン進行、カードプレイ、戦闘など）に応じて期待通りに変化することを検証するテスト。
* **(将来的には) 結合テストの検討**:
    * 複数の関数やモジュールが連携して動作する、より大きな単位でのシナリオテストも視野に入れます。（ただし、これはユニットテストの範囲を少し超える可能性があります。）